## 목차
- [인터페이스 추상클래스](#인터페이스-추상클래스)
- [제네릭](#제네릭)
- [자바와 C](#자바와-c)
- [자바와 파이썬](#자바와-파이썬)
- [기본형과 참조형](#기본형과-참조형)
- [깊은 복사 얕은 복사](#깊은-복사-얕은-복사)
- [==, hashcode, equals 차이 / toString()](#-hashcode-equals-차이--tostring)
- [박싱과 언박싱 차이](#박싱과-언박싱-차이)
- [접근제어자](#접근제어자)

<br>

# 인터페이스 추상클래스

- 추상클래스

  - **미완성 설계도**
  - 변수와 상수 모두 가짐

  - 일반메소드, 추상 메소드 모두 가짐
  - 단일 상속만

- 인터페이스

  - **밑그림만 그려진 기본 설계도**
  - 상수만 가짐
  - 추상메소드만 가짐
  - 다중 상속 가능

  - Java 8이후로 인터페이스도 디폴트 메서드를 가질 수 있음
    - 디폴트 메서드 : 인터페이스에서 body를 가지는 메서드, public

<br>

# 제네릭

- 사용할 데이터 타입을 외부에서 지정하는 기법
- 컴파일 타임에 타입을 체크해 코드의 안전성을 높여줌
- 타입 변환 제거 가능, 타입 안전성 높여줌
- 와일드카드(모든 타입, 하위 타입, 상위 타입)
![image](https://user-images.githubusercontent.com/52027965/170988899-8b5f24ad-d0f0-42fd-bb5a-c5f781b6ece6.png)

<br>

# 자바와 C

- C언어
  - 절차 지향 언어
  - 빠름
  - 유지보수 어려움
  - 메모리 직접 조절해 메모리 낭비가 적음
- 자바
  - 객체 지향 언어
  - JVM의 존재로 인해 두 번 번역돼 상대적으로 느림
  - 컴파일 언어이자 인터프리터 언어(자바 컴파일러가 JVM이 읽을 수 있는 바이트 코드로 번역, JVM에서 운영체제에 맞게 인터프리터로 바이너리 코드로 번역해 실행)
  - GC가 자동으로 메모리 조절

<br>

# 자바와 파이썬

- 파이썬
  - 중괄호 없이 들여 쓰기 가능
  - 데이터 유형 정의 불필요(동적타입 언어 - 런타임시에 결정)
  - 인터프리터 언어

<br>

# 기본형과 참조형

![image](https://user-images.githubusercontent.com/52027965/172899706-60de3366-bb25-4834-95ec-aefd8e29f00b.png)
- 기본형 : 값을 그대로 할당
- 참조형 : 값이 저장된 주소값을 할당
- 참조형은 null값을 가질 수 있지만 기본형은 null값을 가질 수 없다

<br>

# 깊은 복사 얕은 복사

- 깊은복사 : 실제값 복사
- 얕은복사 : 주소값 복사

<br>

# ==, hashcode, equals 차이 / toString()

- == : 주소값 비교
- equals : 내부값 비교
- hashcode : 메모리 번지를 해싱
- 자바에서는 동등성 비교시 hashcode()를 먼저 실행하고 hashcode()값이 같으면 equals()로 다시 비교한다
- toString() : 클래스이름@해시코드

<br>

# 박싱과 언박싱 차이

![image](https://user-images.githubusercontent.com/52027965/172901247-eadbe0b6-f6db-427e-aec3-20c344c4985e.png)
- 박싱 : 기본 자료형의 데이터를 대응되는 래퍼 클래스로 만드는 동작
- 언박싱 : 박싱 반대
- 제네릭은 primitive type을 받지 않기 때문에 래퍼 클래스 사용

<br>

# 접근제어자

![image](https://user-images.githubusercontent.com/52027965/172902966-d2f98f4d-e267-4467-91a6-650019e63304.png)